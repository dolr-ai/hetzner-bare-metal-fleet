name: Provision and Configure Bare Metal Server

on:
  # Manual trigger only
  workflow_dispatch:
    inputs:
      target_host:
        description: "Target host to provision (must exist in inventory)"
        required: true
        type: string
      additional_ssh_keys:
        description: "Additional SSH keys to add (github-actions and saikatdas always included)"
        required: false
        default: "none"
        type: choice
        options:
          - none
          - joel@gobazzinga.io
          - jay@gobazzinga.io
          - kevin@gobazzinga.io
          - ravi@gobazzinga.io
          - naitik@gobazzinga.io
          - all
      custom_ssh_keys:
        description: "Custom SSH key fingerprints (comma-separated, optional)"
        required: false
        type: string
      auto_configure:
        description: "Run post-provision configuration (SSH, Docker, Beszel)"
        required: false
        default: true
        type: boolean

env:
  ANSIBLE_HOST_KEY_CHECKING: False
  ANSIBLE_FORCE_COLOR: True

jobs:
  provision-and-configure:
    name: Provision and Configure Server
    runs-on: ubuntu-latest
    timeout-minutes: 150

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install pyyaml requests ansible ansible-core
          ansible-galaxy collection install ansible.posix community.general

      - name: Get server IP from inventory
        id: get-ip
        run: |
          python3 << 'EOF'
          import yaml
          import os

          with open('ansible/inventory/hosts.yml', 'r') as f:
              inventory = yaml.safe_load(f)

          hostname = "${{ github.event.inputs.target_host }}"
          hosts = inventory.get('all', {}).get('children', {}).get('bare_metal', {}).get('hosts', {})

          if hostname not in hosts:
              print(f"Error: Host {hostname} not found in inventory")
              exit(1)

          host_vars = hosts[hostname]
          ansible_host = host_vars.get('ansible_host')
          server_id = host_vars.get('hetzner_server_id')

          if not ansible_host:
              print(f"Error: ansible_host not found for {hostname}")
              exit(1)

          print(f"Found IP: {ansible_host}")

          # Output to GitHub Actions
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"server_ip={ansible_host}\n")
              if server_id:
                  f.write(f"server_id={server_id}\n")
          EOF

      - name: Activate rescue mode via Hetzner API
        id: activate-rescue
        env:
          HETZNER_API_USER: ${{ secrets.HETZNER_ROBOT_USER }}
          HETZNER_API_PASSWORD: ${{ secrets.HETZNER_ROBOT_PASSWORD }}
        run: |
          python3 << 'EOF'
          import requests
          import json
          import os
          import sys
          from requests.auth import HTTPBasicAuth

          # Get credentials from environment
          api_user = os.environ.get('HETZNER_API_USER')
          api_password = os.environ.get('HETZNER_API_PASSWORD')
          server_ip = "${{ steps.get-ip.outputs.server_ip }}"
          rescue_os = "linux"
          arch = "64"
          additional_keys = "${{ github.event.inputs.additional_ssh_keys }}"
          custom_keys = "${{ github.event.inputs.custom_ssh_keys }}"

          if not api_user or not api_password:
              print("Error: HETZNER_ROBOT_USER and HETZNER_ROBOT_PASSWORD secrets must be set")
              sys.exit(1)

          # First, fetch all SSH keys from Hetzner to get valid fingerprints
          print("Fetching SSH keys from Hetzner API...")
          keys_url = "https://robot-ws.your-server.de/key"

          try:
              keys_response = requests.get(
                  keys_url,
                  auth=HTTPBasicAuth(api_user, api_password)
              )
              keys_response.raise_for_status()
              keys_data = keys_response.json()
              
              # Build a mapping of key names to fingerprints
              hetzner_keys = {}
              for key_entry in keys_data:
                  key_info = key_entry.get('key', {})
                  name = key_info.get('name', '')
                  fingerprint = key_info.get('fingerprint', '')
                  if name and fingerprint:
                      hetzner_keys[name.lower()] = fingerprint
                      # Also try matching by email in name
                      if '@' in name:
                          email = name.lower()
                          hetzner_keys[email] = fingerprint
              
              print(f"Found {len(hetzner_keys)} keys in Hetzner: {list(hetzner_keys.keys())}")
              
          except requests.exceptions.RequestException as e:
              print(f"Warning: Failed to fetch SSH keys from Hetzner: {e}")
              hetzner_keys = {}

          # Define SSH key mapping - try to match with Hetzner keys
          ssh_keys_map = {
              "github-actions": "github-actions@yral.com",
              "saikatdas": "saikatdas0790@gmail.com",
              "joel@gobazzinga.io": "joel@gobazzinga.io",
              "jay@gobazzinga.io": "jay@gobazzinga.io",
              "kevin@gobazzinga.io": "kevin@gobazzinga.io",
              "ravi@gobazzinga.io": "ravi@gobazzinga.io",
              "naitik@gobazzinga.io": "naitik@gobazzinga.io"
          }

          # Build list of fingerprints to use
          key_list = []

          # Always try to include default keys
          for key_name in ["github-actions", "saikatdas"]:
              email = ssh_keys_map[key_name]
              if email in hetzner_keys:
                  key_list.append(hetzner_keys[email])
                  print(f"Added {key_name} ({email}): {hetzner_keys[email]}")
              else:
                  print(f"Warning: {key_name} ({email}) not found in Hetzner keys")

          # Add additional keys based on selection
          if additional_keys == "all":
              for email in ["joel@gobazzinga.io", "jay@gobazzinga.io", "kevin@gobazzinga.io", 
                          "ravi@gobazzinga.io", "naitik@gobazzinga.io"]:
                  if email in hetzner_keys:
                      key_list.append(hetzner_keys[email])
                      print(f"Added {email}: {hetzner_keys[email]}")
          elif additional_keys != "none":
              email = additional_keys
              if email in hetzner_keys:
                  key_list.append(hetzner_keys[email])
                  print(f"Added {email}: {hetzner_keys[email]}")

          # Add custom keys if provided (assuming these are fingerprints)
          if custom_keys:
              custom_list = [k.strip() for k in custom_keys.split(',') if k.strip()]
              key_list.extend(custom_list)
              print(f"Added {len(custom_list)} custom key(s)")

          # Hetzner Robot API endpoint
          api_url = f"https://robot-ws.your-server.de/boot/{server_ip}/rescue"

          # Add keys to payload - Hetzner API expects multiple authorized_key[] parameters
          print(f"\nActivating rescue mode for {server_ip}...")
          print(f"OS: {rescue_os}, Arch: {arch}")
          print(f"Total keys to add: {len(key_list)}")

          # Make API request - send authorized_key[] as multiple form parameters
          try:
              # Build form data with multiple authorized_key[] parameters
              form_data = [
                  ('os', rescue_os),
                  ('arch', arch)
              ]
              for key in key_list:
                  form_data.append(('authorized_key[]', key))
              
              response = requests.post(
                  api_url,
                  auth=HTTPBasicAuth(api_user, api_password),
                  data=form_data
              )
              
              response.raise_for_status()
              result = response.json()
              
              # Extract rescue password
              rescue_password = result.get('rescue', {}).get('password')
              
              if rescue_password:
                  print(f"✅ Rescue mode activated successfully!")
                  print(f"Server IP: {server_ip}")
                  
                  # Mask the password in logs but save it for job summary
                  print(f"::add-mask::{rescue_password}")
                  
                  # Output to GitHub Actions (will be masked)
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"rescue_password={rescue_password}\n")
                      f.write(f"success=true\n")
                  
                  print("\n⚠️  IMPORTANT: Save the rescue password from the job summary!")
              else:
                  print("❌ Failed to get rescue password from API response")
                  print(f"Response: {json.dumps(result, indent=2)}")
                  sys.exit(1)
                  
          except requests.exceptions.RequestException as e:
              print(f"❌ API request failed: {e}")
              if hasattr(e.response, 'text'):
                  print(f"Response: {e.response.text}")
              sys.exit(1)
          EOF

      - name: Reboot server via Hetzner API
        env:
          HETZNER_API_USER: ${{ secrets.HETZNER_ROBOT_USER }}
          HETZNER_API_PASSWORD: ${{ secrets.HETZNER_ROBOT_PASSWORD }}
        run: |
          python3 << 'EOF'
          import requests
          import os
          import sys
          from requests.auth import HTTPBasicAuth

          api_user = os.environ.get('HETZNER_API_USER')
          api_password = os.environ.get('HETZNER_API_PASSWORD')
          server_ip = "${{ steps.get-ip.outputs.server_ip }}"

          api_url = f"https://robot-ws.your-server.de/reset/{server_ip}"

          print(f"Triggering hardware reset for {server_ip}...")

          try:
              response = requests.post(
                  api_url,
                  auth=HTTPBasicAuth(api_user, api_password),
                  data={"type": "hw"}
              )
              
              response.raise_for_status()
              print("✅ Hardware reset triggered successfully!")
              print("Server will reboot into rescue mode...")
              
          except requests.exceptions.RequestException as e:
              print(f"❌ Reset request failed: {e}")
              if hasattr(e.response, 'text'):
                  print(f"Response: {e.response.text}")
              sys.exit(1)
          EOF

      - name: Wait for server to boot into rescue
        run: |
          echo "⏳ Waiting 120 seconds for server to boot into rescue mode..."
          sleep 120

      - name: Test SSH connectivity to rescue system
        env:
          RESCUE_PASSWORD: ${{ steps.activate-rescue.outputs.rescue_password }}
        run: |
          server_ip="${{ steps.get-ip.outputs.server_ip }}"

          echo "Testing SSH connectivity to rescue system..."

          # Install sshpass for password authentication
          sudo apt-get update && sudo apt-get install -y sshpass

          # Try to connect (with retries)
          max_attempts=10
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts..."
            
            if sshpass -p "$RESCUE_PASSWORD" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$server_ip "echo 'Connected to rescue system'; uname -a"; then
              echo "✅ Successfully connected to rescue system!"
              exit 0
            fi
            
            echo "Connection failed, waiting 30 seconds..."
            sleep 30
            attempt=$((attempt + 1))
          done

          echo "❌ Failed to connect after $max_attempts attempts"
          exit 1

      - name: Set up SSH key for Ansible
        env:
          SSH_PRIVATE_KEY: ${{ secrets.HETZNER_BARE_METAL_GITHUB_ACTIONS_SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          # Add SSH agent configuration
          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/id_ed25519

      - name: Set up Ansible vault password
        env:
          VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}
        run: |
          if [ -z "$VAULT_PASSWORD" ]; then
            echo "::error::ANSIBLE_VAULT_PASSWORD secret is not set or is empty"
            echo "Please add the vault password as a repository secret named ANSIBLE_VAULT_PASSWORD"
            exit 1
          fi
          cd ansible
          echo "$VAULT_PASSWORD" > .vault_pass
          chmod 600 .vault_pass
          echo "✓ Vault password file created"

      - name: Run bare metal provisioning
        run: |
          cd ansible
          ansible-playbook \
            --limit ${{ github.event.inputs.target_host }} \
            -v \
            playbooks/bare-metal-provision.yml

      - name: Run SSH security playbook
        if: ${{ inputs.auto_configure == true }}
        run: |
          cd ansible
          ansible-playbook \
            --limit ${{ github.event.inputs.target_host }} \
            -v \
            playbooks/ssh-security.yml

      - name: Run Docker setup playbook
        if: ${{ inputs.auto_configure == true }}
        run: |
          cd ansible
          ansible-playbook \
            --limit ${{ github.event.inputs.target_host }} \
            -v \
            playbooks/docker-setup.yml

      - name: Run Beszel agent setup playbook
        if: ${{ inputs.auto_configure == true }}
        run: |
          cd ansible
          ansible-playbook \
            --limit ${{ github.event.inputs.target_host }} \
            -v \
            playbooks/beszel-agent-setup.yml

      - name: Generate provisioning summary
        if: always()
        env:
          RESCUE_PASSWORD: ${{ steps.activate-rescue.outputs.rescue_password }}
        run: |
          echo "## Provision and Configure Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Target Host:** ${{ github.event.inputs.target_host }}" >> $GITHUB_STEP_SUMMARY
          echo "**Server IP:** ${{ steps.get-ip.outputs.server_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "**Auto Configure:** ${{ inputs.auto_configure }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.activate-rescue.outputs.success }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Rescue Password" >> $GITHUB_STEP_SUMMARY
            echo "\`$RESCUE_PASSWORD\`" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -f ansible/ansible.log ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Ansible Log Summary" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            tail -20 ansible/ansible.log >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload Ansible logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: provision-${{ github.event.inputs.target_host }}-${{ github.run_id }}
          path: |
            ansible/ansible.log
          retention-days: 30

      - name: Notify on failure
        if: failure()
        run: |
          echo "::error::Provisioning failed for: ${{ github.event.inputs.target_host }}"
          echo "Check the logs and artifacts for more details."
