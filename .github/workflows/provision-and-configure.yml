name: Provision and Configure Bare Metal Server

on:
  # Manual trigger only
  workflow_dispatch:
    inputs:
      target_host:
        description: "Target host to provision (must exist in inventory)"
        required: true
        type: string
      additional_ssh_keys:
        description: "Additional SSH keys to add (github-actions and saikatdas always included)"
        required: false
        default: "none"
        type: choice
        options:
          - none
          - joel@gobazzinga.io
          - jay@gobazzinga.io
          - kevin@gobazzinga.io
          - ravi@gobazzinga.io
          - naitik@gobazzinga.io
          - all
      custom_ssh_keys:
        description: "Custom SSH key fingerprints (comma-separated, optional)"
        required: false
        type: string
      auto_configure:
        description: "Run post-provision configuration (SSH, Docker, Beszel)"
        required: false
        default: true
        type: boolean
      force_provision:
        description: "Force provisioning even if server is already provisioned (DESTRUCTIVE)"
        required: false
        default: false
        type: boolean

env:
  ANSIBLE_HOST_KEY_CHECKING: False
  ANSIBLE_FORCE_COLOR: True

jobs:
  provision-and-configure:
    name: Provision and Configure Server
    runs-on: ubuntu-latest
    timeout-minutes: 150

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install pyyaml requests ansible ansible-core
          ansible-galaxy collection install ansible.posix community.general

      - name: Get server IP from inventory
        id: get-ip
        run: |
          python3 << 'EOF'
          import yaml
          import os

          with open('ansible/inventory/hosts.yml', 'r') as f:
              inventory = yaml.safe_load(f)

          hostname = "${{ github.event.inputs.target_host }}"
          hosts = inventory.get('all', {}).get('children', {}).get('bare_metal', {}).get('hosts', {})

          if hostname not in hosts:
              print(f"Error: Host {hostname} not found in inventory")
              exit(1)

          host_vars = hosts[hostname]
          ansible_host = host_vars.get('ansible_host')
          server_id = host_vars.get('hetzner_server_id')

          if not ansible_host:
              print(f"Error: ansible_host not found for {hostname}")
              exit(1)

          print(f"Found IP: {ansible_host}")

          # Output to GitHub Actions
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"server_ip={ansible_host}\n")
              if server_id:
                  f.write(f"server_id={server_id}\n")
          EOF

      - name: Activate rescue mode via Hetzner API
        id: activate-rescue
        env:
          HETZNER_API_USER: ${{ secrets.HETZNER_ROBOT_USER }}
          HETZNER_API_PASSWORD: ${{ secrets.HETZNER_ROBOT_PASSWORD }}
        run: |
          python3 << 'EOF'
          import requests
          import json
          import os
          import sys
          from requests.auth import HTTPBasicAuth

          # Get credentials from environment
          api_user = os.environ.get('HETZNER_API_USER')
          api_password = os.environ.get('HETZNER_API_PASSWORD')
          server_ip = "${{ steps.get-ip.outputs.server_ip }}"
          rescue_os = "linux"
          arch = "64"
          additional_keys = "${{ github.event.inputs.additional_ssh_keys }}"
          custom_keys = "${{ github.event.inputs.custom_ssh_keys }}"

          if not api_user or not api_password:
              print("Error: HETZNER_ROBOT_USER and HETZNER_ROBOT_PASSWORD secrets must be set")
              sys.exit(1)

          # First, fetch all SSH keys from Hetzner to get valid fingerprints
          print("Fetching SSH keys from Hetzner API...")
          keys_url = "https://robot-ws.your-server.de/key"

          try:
              keys_response = requests.get(
                  keys_url,
                  auth=HTTPBasicAuth(api_user, api_password)
              )
              keys_response.raise_for_status()
              keys_data = keys_response.json()
              
              # Build a mapping of key names to fingerprints
              hetzner_keys = {}
              for key_entry in keys_data:
                  key_info = key_entry.get('key', {})
                  name = key_info.get('name', '')
                  fingerprint = key_info.get('fingerprint', '')
                  if name and fingerprint:
                      hetzner_keys[name.lower()] = fingerprint
                      # Also try matching by email in name
                      if '@' in name:
                          email = name.lower()
                          hetzner_keys[email] = fingerprint
              
              print(f"Found {len(hetzner_keys)} keys in Hetzner: {list(hetzner_keys.keys())}")
              
          except requests.exceptions.RequestException as e:
              print(f"Warning: Failed to fetch SSH keys from Hetzner: {e}")
              hetzner_keys = {}

          # Define SSH key mapping - try to match with Hetzner keys
          ssh_keys_map = {
              "github-actions": "github-actions@yral.com",
              "saikatdas": "saikatdas0790@gmail.com",
              "joel@gobazzinga.io": "joel@gobazzinga.io",
              "jay@gobazzinga.io": "jay@gobazzinga.io",
              "kevin@gobazzinga.io": "kevin@gobazzinga.io",
              "ravi@gobazzinga.io": "ravi@gobazzinga.io",
              "naitik@gobazzinga.io": "naitik@gobazzinga.io"
          }

          # Build list of fingerprints to use
          key_list = []

          # Always try to include default keys
          for key_name in ["github-actions", "saikatdas"]:
              email = ssh_keys_map[key_name]
              if email in hetzner_keys:
                  key_list.append(hetzner_keys[email])
                  print(f"Added {key_name} ({email}): {hetzner_keys[email]}")
              else:
                  print(f"Warning: {key_name} ({email}) not found in Hetzner keys")

          # Add additional keys based on selection
          if additional_keys == "all":
              for email in ["joel@gobazzinga.io", "jay@gobazzinga.io", "kevin@gobazzinga.io", 
                          "ravi@gobazzinga.io", "naitik@gobazzinga.io"]:
                  if email in hetzner_keys:
                      key_list.append(hetzner_keys[email])
                      print(f"Added {email}: {hetzner_keys[email]}")
          elif additional_keys != "none":
              email = additional_keys
              if email in hetzner_keys:
                  key_list.append(hetzner_keys[email])
                  print(f"Added {email}: {hetzner_keys[email]}")

          # Add custom keys if provided (assuming these are fingerprints)
          if custom_keys:
              custom_list = [k.strip() for k in custom_keys.split(',') if k.strip()]
              key_list.extend(custom_list)
              print(f"Added {len(custom_list)} custom key(s)")

          # Hetzner Robot API endpoint
          api_url = f"https://robot-ws.your-server.de/boot/{server_ip}/rescue"

          # Add keys to payload - Hetzner API expects multiple authorized_key[] parameters
          print(f"\nActivating rescue mode for {server_ip}...")
          print(f"OS: {rescue_os}, Arch: {arch}")
          print(f"Total keys to add: {len(key_list)}")

          # Make API request - send authorized_key[] as multiple form parameters
          try:
              # Build form data with multiple authorized_key[] parameters
              form_data = [
                  ('os', rescue_os),
                  ('arch', arch)
              ]
              for key in key_list:
                  form_data.append(('authorized_key[]', key))
              
              response = requests.post(
                  api_url,
                  auth=HTTPBasicAuth(api_user, api_password),
                  data=form_data
              )
              
              response.raise_for_status()
              result = response.json()
              
              # Verify rescue mode was activated
              if result.get('rescue', {}).get('active'):
                  print(f"✅ Rescue mode activated successfully!")
                  print(f"Server IP: {server_ip}")
                  
                  # Output to GitHub Actions
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"success=true\n")
              else:
                  print("❌ Failed to activate rescue mode")
                  print(f"Response: {json.dumps(result, indent=2)}")
                  sys.exit(1)
                  
          except requests.exceptions.RequestException as e:
              print(f"❌ API request failed: {e}")
              if hasattr(e.response, 'text'):
                  print(f"Response: {e.response.text}")
              sys.exit(1)
          EOF

      - name: Reboot server via Hetzner API
        env:
          HETZNER_API_USER: ${{ secrets.HETZNER_ROBOT_USER }}
          HETZNER_API_PASSWORD: ${{ secrets.HETZNER_ROBOT_PASSWORD }}
        run: |
          python3 << 'EOF'
          import requests
          import os
          import sys
          from requests.auth import HTTPBasicAuth

          api_user = os.environ.get('HETZNER_API_USER')
          api_password = os.environ.get('HETZNER_API_PASSWORD')
          server_ip = "${{ steps.get-ip.outputs.server_ip }}"

          api_url = f"https://robot-ws.your-server.de/reset/{server_ip}"

          print(f"Triggering hardware reset for {server_ip}...")

          try:
              response = requests.post(
                  api_url,
                  auth=HTTPBasicAuth(api_user, api_password),
                  data={"type": "hw"}
              )
              
              response.raise_for_status()
              print("✅ Hardware reset triggered successfully!")
              print("Server will reboot into rescue mode...")
              
          except requests.exceptions.RequestException as e:
              print(f"❌ Reset request failed: {e}")
              if hasattr(e.response, 'text'):
                  print(f"Response: {e.response.text}")
              sys.exit(1)
          EOF

      - name: Wait for server to boot into rescue
        run: |
          echo "⏳ Waiting 120 seconds for server to boot into rescue mode..."
          sleep 120

      - name: Set up SSH key for Ansible
        env:
          SSH_PRIVATE_KEY: ${{ secrets.HETZNER_BARE_METAL_GITHUB_ACTIONS_SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          # Add SSH agent configuration
          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/id_ed25519

      - name: Test SSH connectivity to rescue system
        run: |
          server_ip="${{ steps.get-ip.outputs.server_ip }}"

          echo "Testing SSH connectivity to rescue system..."

          # Try to connect using SSH key (with retries)
          max_attempts=10
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts..."
            
            # First check if we can connect at all
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes root@$server_ip "echo 'SSH connection successful'"; then
              # Check if we're in rescue mode
              if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes root@$server_ip "test -f /root/.oldroot/nfs/install/installimage"; then
                echo "✅ Successfully connected to rescue system!"
                ssh -o StrictHostKeyChecking=no root@$server_ip "uname -a"
                exit 0
              else
                echo "❌ Server is accessible but NOT in rescue mode!"
                echo "The server appears to be running the installed OS."
                echo ""
                echo "To fix this:"
                echo "1. Go to Hetzner Robot panel: https://robot.hetzner.com/"
                echo "2. Select server: $server_ip"
                echo "3. Go to 'Rescue' tab and activate Linux rescue system"
                echo "4. Go to 'Reset' tab and trigger a hardware reset"
                echo "5. Wait 2-3 minutes for the server to boot into rescue mode"
                echo "6. Re-run this workflow"
                exit 1
              fi
            fi
            
            echo "Connection failed, waiting 30 seconds..."
            sleep 30
            attempt=$((attempt + 1))
          done

          echo "❌ Failed to connect after $max_attempts attempts"
          echo "Server is not accessible via SSH. Please check:"
          echo "1. Server is powered on"
          echo "2. Network connectivity is working"
          echo "3. SSH keys are properly configured in Hetzner Robot"
          exit 1

      - name: Set up Ansible vault password
        env:
          VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}
        run: |
          if [ -z "$VAULT_PASSWORD" ]; then
            echo "::error::ANSIBLE_VAULT_PASSWORD secret is not set or is empty"
            echo "Please add the vault password as a repository secret named ANSIBLE_VAULT_PASSWORD"
            exit 1
          fi
          cd ansible
          echo "$VAULT_PASSWORD" > .vault_pass
          chmod 600 .vault_pass
          echo "✓ Vault password file created"

      - name: Run bare metal provisioning
        run: |
          cd ansible
          ansible-playbook \
            --limit ${{ github.event.inputs.target_host }} \
            -v \
            ${{ github.event.inputs.force_provision == 'true' && '-e force_provision=true' || '' }} \
            playbooks/bare-metal-provision.yml

      - name: Run SSH security playbook
        if: ${{ inputs.auto_configure == true }}
        run: |
          cd ansible
          ansible-playbook \
            --limit ${{ github.event.inputs.target_host }} \
            -v \
            playbooks/ssh-security.yml

      - name: Run Docker setup playbook
        if: ${{ inputs.auto_configure == true }}
        run: |
          cd ansible
          ansible-playbook \
            --limit ${{ github.event.inputs.target_host }} \
            -v \
            playbooks/docker-setup.yml

      - name: Run Beszel agent setup playbook
        if: ${{ inputs.auto_configure == true }}
        run: |
          cd ansible
          ansible-playbook \
            --limit ${{ github.event.inputs.target_host }} \
            -v \
            playbooks/beszel-agent-setup.yml

      - name: Generate provisioning summary
        if: always()
        run: |
          echo "## Provision and Configure Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Target Host:** ${{ github.event.inputs.target_host }}" >> $GITHUB_STEP_SUMMARY
          echo "**Server IP:** ${{ steps.get-ip.outputs.server_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "**Auto Configure:** ${{ inputs.auto_configure }}" >> $GITHUB_STEP_SUMMARY
          echo "**Force Provision:** ${{ inputs.force_provision }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            tail -20 ansible/ansible.log >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload Ansible logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: provision-${{ github.event.inputs.target_host }}-${{ github.run_id }}
          path: |
            ansible/ansible.log
          retention-days: 30

      - name: Notify on failure
        if: failure()
        run: |
          echo "::error::Provisioning failed for: ${{ github.event.inputs.target_host }}"
          echo "Check the logs and artifacts for more details."
